package `in`.curioustools.dagger1.a3_binds

import dagger.Binds
import dagger.Component
import dagger.Module
import dagger.Provides
import javax.inject.Inject



/*
* The @binds is almost similar to @provides, but only in terms of creating an interface instance
*  more efficiently. How its similar/dissimarl etc: more details here :https://dagger.dev/dev-guide/faq.html
*
* for using binds to generate our interface, we replace our general @Module CONCRETE class
* with a abstract class. Binds can only generate interface implementations and not the class based
* dependencies, so we will have to make another @Module class for all the UnAnnotable Model depenedencies
*
* We first create a class which implements the UnAnnotable Interface abstractX  .
* lets call this implementing class as  X. we use @inject annotation in X's constructor,
* which allows dagger to create isntances of it and pass whenever and wherever  required.
*
*
* then in our now Abstract Provider Class, we create an abstract function which will take an object
* of class X and return interface object absX . this definition is generated by Dagger  when compiled
*
* But remember, BINDS AND ABSTRACT MODULE WORKS FOR ONLY INTERFACE OBJECTS, NOT  MODELS
* OBJECTS . for those, you will either have to provide an @Inject annotation or a manual injection,
* i,e a concrete seperate module.
*
* Also after generating  the dagger code via build command, you will see that the function annotated
* with @binds is not being used anywhere. you may get tempted to remove @Binds completelty  but don't
*
* // check out the test class @ProvideTest for more run time example
* */



//-------------------main model---------------------------
class Tractor @Inject constructor(val roller: Roller ,val engine: Engine)



//----------un-annotatable dependency( a class) --------------
class Roller

//----------un-annotatable dependency( an interface) --------------


interface Engine{
    fun getEngineDetails():String
}

// the interface implemented in a new model
class DieselEngine @Inject constructor() :Engine{
    override fun getEngineDetails(): String {
        return "This is a diesel engine"
    }
}

//--------------------------------modules------------------------------------

@Module
abstract class  AbstractUIPModuleForEngineInterface{ //Unannotated interface object (depedency) provider Module for Abstract Engine interface
    @Binds
    abstract fun getEngineInstance(engine: DieselEngine):Engine

}

@Module class  UMPModuleForRoller{//Unannotated (model) dependency provider Module for Roller class


    @Provides
    fun getRollerInstance() = Roller()
}
//-------------------------------component - --------------------------------

@Component(modules = [AbstractUIPModuleForEngineInterface::class, UMPModuleForRoller::class])
interface  TractorGeneratorComponent{

    fun getTractor():Tractor
}